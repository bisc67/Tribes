#include "x_files.hpp"
#include "package.hpp"
#include <stdlib.h>
#include "iopaudio.h"
#include "decode.hpp"
#include "encode.hpp"
#include "../../support/audiomgr/audio.hpp"

extern s32 verbose_flag;


s16 package_Adsr1(parse_envelope &Envelope);
s16 package_Adsr2(parse_envelope &Envelope);
//-----------------------------------------------------------------------------
void AddLabelHeader(X_FILE *fp_label,s32 containerid)
{
    x_fprintf(fp_label,"#ifndef __SOUND_TYPES_%02x_H__\n#define __SOUND_TYPES_%02x_H__\n",containerid,containerid);
    x_fprintf(fp_label,"// THIS FILE IS AUTOMATICALLY GENERATED BY SOUNDPKG\n");
    x_fprintf(fp_label,"// SO THERE IS NO POINT MODIFYING IT BY HAND!\n");
    x_fprintf(fp_label,"// Sound format version %d, Built on %s at %s\n",CONTAINER_VERSION_NUMBER,__DATE__,__TIME__);
    x_fprintf(fp_label,"// Sound Types\nBEGIN_LABEL_SET(SoundTypes_%02x)\n",containerid);
}

//-----------------------------------------------------------------------------
void AddLabel(X_FILE *fp_label,char *label,s32 id,char *filename)
{
    x_fprintf(fp_label,"    LABEL_VALUE(%-32s,%8d,  \"%s\")\n",label,id,filename);
}

//-----------------------------------------------------------------------------
void AddLabelFooter(X_FILE *fp_label,s32 containerid)
{
    x_fprintf(fp_label,"END_LABEL_SET(SoundTypes_%02x)\n#endif  // __SOUND_TYPES_%02x_H__\n",containerid,containerid);
}

s32  FindComplex(parse_output &Output,char *pName)
{
    complex_effect *pCfx;

    pCfx = Output.m_pEffectHead;

    while (pCfx)
    {
        if (x_strcmp(pCfx->m_Label,pName)==0)
            return pCfx->m_Id;
        pCfx = pCfx->m_pNext;
    }
    return -1;
}

void dump_complex(parse_output &Output,complex_effect *pEffect)
{
    char *pName;

    if (!verbose_flag)
        return;
    pName = pEffect->m_Label;
    if (x_strlen(pName) > 18)
    {
        pName = pName + x_strlen(pName) - 18;
    }
    x_printf("name:%18s, id=%d, ty:%d, fl=%d, pr=%d, vo=%.1f,pi=%.1f,de=%.1f,Co=%d",
                pName,
                pEffect->m_Id,
                pEffect->m_Type,
                pEffect->m_Vars.m_Flags,
                pEffect->m_Vars.m_Priority,
                (f32)pEffect->m_Vars.m_Volume,
                (f32)pEffect->m_Vars.m_Pitch,
                (f32)pEffect->m_Vars.m_Delay,
                pEffect->m_Count);
    if (pEffect->m_Type != CFXTYPE_COMPLEX)
    {
        x_printf(",ofs=%08x\n",pEffect->m_pSample->m_MediaLocation);
    }
    else
    {
        x_printf(",id=%d\n",FindComplex(Output,pEffect->m_Label));
    }
}
//-----------------------------------------------------------------------------
void    package_Element(parse_output &Output,X_FILE *fp,complex_effect *pElement)
{
    cfx_stored_element Stored;

    

    Stored.m_Type      = TargetEndian16((s16)pElement->m_Type                               );
    Stored.m_Flags     = TargetEndian16((s16)pElement->m_Vars.m_Flags                       );
    Stored.m_Priority  = TargetEndian16((s16)pElement->m_Vars.m_Priority                    );
    Stored.m_Volume    = TargetEndian16((s16)(pElement->m_Vars.m_Volume * AUD_FIXED_POINT_1));
    Stored.m_Pitch     = TargetEndian16((s16)(pElement->m_Vars.m_Pitch * AUD_FIXED_POINT_1) );
    Stored.m_Delay     = TargetEndian16((s16)(pElement->m_Vars.m_Delay * 1000.0f)           );
    Stored.m_Falloff   = TargetEndian16((s16)(pElement->m_Vars.m_Falloff * AUD_FIXED_POINT_1));
    Stored.m_Pan       = TargetEndian16((s16)(pElement->m_Vars.m_Pan * AUD_FIXED_POINT_1    ));
    Stored.m_Count     = TargetEndian32(0                                                   );
    Stored.m_OwnerId   = TargetEndian32(pElement->m_Owner | (Output.m_PackageId<<24)        );

    Stored.m_ADSR1          = TargetEndian32(package_Adsr1(pElement->m_Vars.m_Envelope));
    Stored.m_ADSR2          = TargetEndian32(package_Adsr2(pElement->m_Vars.m_Envelope));

    Output.m_CfxCount++;

    if (pElement->m_Type != CFXTYPE_COMPLEX)
    {
        Stored.m_SampleRate     = TargetEndian16(pElement->m_pSample->m_SampleRate  );
        Stored.m_Length         = TargetEndian32(pElement->m_pSample->m_Length      );
        Stored.m_MediaLocation  = TargetEndian32(pElement->m_pSample->m_MediaLocation);
        Stored.m_Flags         |= TargetEndian16(pElement->m_pSample->m_Flags       );
        ASSERT(pElement->m_pSample);
    }
    else
    {
        Stored.m_SampleRate = -1;
        Stored.m_Length =-1;
        Stored.m_MediaLocation = FindComplex(Output,pElement->m_Label)|(Output.m_PackageId<<24);
        ASSERT(!pElement->m_pSample);
        if (Stored.m_MediaLocation == -1)
        {
            x_printf("Cannot find complex element '%s' during patchup\n",pElement->m_Label);
            exit(-1);
        }
    }

    dump_complex(Output,pElement);
    x_fwrite(&Stored,sizeof(Stored),1,fp);
}

void    package_cfx(parse_output &Output,X_FILE *fp,complex_effect *pEffect)
{
    complex_effect *pElement;
    complex_effect *pChildren;
    s32             file_pos;
    s32             file_pos2;
    cfx_stored_element Stored;
    s32             count;

    if (pEffect->m_Type != CFXTYPE_COMPLEX)
    {
        package_Element(Output,fp,pEffect);
        return;
    }
    //
    // First pass, we go through each element's children list and write
    // those out first. Note: we do not write out the children's element
    // list as that will be done on the second pass.
    //
    file_pos = x_ftell(fp);
    // Do a dummy write on our element
    x_fwrite(&Stored,sizeof(Stored),1,fp);

    pElement = pEffect;

    Stored.m_Type           = TargetEndian16(pElement->m_Type                             );
    Stored.m_Flags          = TargetEndian16(pElement->m_Vars.m_Flags                     );
    Stored.m_Priority       = TargetEndian16(pElement->m_Vars.m_Priority                  );
    Stored.m_Volume         = TargetEndian16((s16)(pElement->m_Vars.m_Volume * AUD_FIXED_POINT_1));
    Stored.m_Pitch          = TargetEndian16((s16)(pElement->m_Vars.m_Pitch * AUD_FIXED_POINT_1 ));
    Stored.m_Delay          = TargetEndian16((s16)(pElement->m_Vars.m_Delay * 1000.0f           ));
    Stored.m_Falloff        = TargetEndian16((s16)(pElement->m_Vars.m_Falloff*AUD_FIXED_POINT_1 ));

    Stored.m_ADSR1          = TargetEndian32(package_Adsr1(pElement->m_Vars.m_Envelope));
    Stored.m_ADSR2          = TargetEndian32(package_Adsr2(pElement->m_Vars.m_Envelope));

    Stored.m_Length         = TargetEndian32(-1);
    Stored.m_MediaLocation  = TargetEndian32(-1);
    Stored.m_SampleRate     = TargetEndian32(-1);

    dump_complex(Output,pEffect);
    pChildren = pElement->m_pChildren;
    count = 0;
    while (pChildren)
    {
        package_Element(Output,fp,pChildren);
        pChildren = pChildren->m_pNext;
        count++;
    }
    Stored.m_Count          = TargetEndian16(count);
    // 
    // Second pass, we actually package up each of the children's cfx. This should
    // produce the flat, top level file structure we're looking for. All top level
    // effects at the earliest part of the file with all of the child elements auto-
    // magically appearing below them. There will be a second pass through the actual
    // file, patching up all the element offsets from an id to an actual location 
    // within the file.
    //
    file_pos2=x_ftell(fp);
    x_fseek(fp,file_pos,X_SEEK_SET);
    x_fwrite(&Stored,sizeof(Stored),1,fp);
    x_fseek(fp,file_pos2,X_SEEK_SET);

}

//-----------------------------------------------------------------------------
void    package_Write(parse_output &Output,xbool verbose_flag)
{
    X_FILE      *fp_output;
    X_FILE      *fp_label;
    parse_variables Defaults;
    sample_body *pSample;
    s32         Base;
    s8          ZeroBuffer[4096];
    s32         zerolength;
    s32         spuused;
    s32         iopused;
    s32         streamused;

    container_header Header;

    x_memset(ZeroBuffer,0x00,4096);
    spuused = 0;
    iopused = 0;
    streamused = 0;

    fp_label = x_fopen(Output.m_LabelFilename,"wa");
    if (!fp_label)
    {
        x_printf("SoundPkg: Cannot open label file [%s]\n",Output.m_LabelFilename);
        exit(-1);
    }

    //
    // Dump our audio file signature at the start
    //
    Header.m_Length         = TargetEndian32(0);
    Header.m_Count          = TargetEndian32(0);
    Header.m_ContainerID    = Output.m_PackageId;

    // To write out our file, first we go through dumping out all the headers.
    // Each header will not have been patched up properly yet but we'll do that
    // on a second pass matching internal identifiers to samples & cfx's

    if (verbose_flag)
    {
        x_printf("%d samples to process\n",Output.m_CfxCount);
    }

    //
    // Write a dummy header and dummy index list so we advance to the
    // correct position within the output file
    //
    x_memcpy(Header.m_Signature,"inevaud",7);
    Header.m_Version    = CONTAINER_VERSION_NUMBER;
    Header.m_Alignment  = TargetEndian32(VOICE_STREAM_ALIGNMENT);
    Header.m_Count      = TargetEndian32(Output.m_CfxCount);
    Output.m_CfxCount   = TargetEndian32(0);

    if (Output.m_PackageFilename[0]==0x0)
    {
        x_printf("SoundPkg: No output package file defined\n");
        exit(-1);
    }
    fp_output = x_fopen(Output.m_PackageFilename,"wb");
    if (!fp_output)
    {
        x_printf("SoundPkg: Cannot open package file [%s]\n",Output.m_PackageFilename);
        exit(-1);
    }
    

    x_fwrite(&Header,1,sizeof(container_header),fp_output);
    // Now, go through the sample list parsed from the control file
    // and append them to the output stream

    //
    // Now write out the beginning part of the label file
    //
    AddLabelHeader(fp_label,Header.m_ContainerID);
//    AddLabel(fp_label,"SOUND_TYPE_NONE",0,"<unassigned>");

    complex_effect *pEffects;

    pEffects = Output.m_pEffectHead;

    while (pEffects)
    {
        if (verbose_flag)
            x_printf("====== %s ======\n",pEffects->m_Label);
        package_cfx(Output,fp_output,pEffects);
        if (!pEffects->m_Hidden)
        {
            AddLabel(fp_label,pEffects->m_Label,pEffects->m_Id|(Output.m_PackageId<<24),pEffects->m_Comment);
        }
        pEffects = pEffects->m_pNext;
    }

    pSample = Output.m_pSamples;

//	if (GetTargetPlatform() != TARGET_TYPE_PC)
//	{
		zerolength = ((x_ftell(fp_output)+4095) & ~4095)-x_ftell(fp_output);
		if (zerolength)
		{
			x_fwrite(ZeroBuffer,zerolength,1,fp_output);
		}

		ASSERT((x_ftell(fp_output) & 4095)==0);
//	}

    Base = x_ftell(fp_output);


	s32 id = 0;
    while (pSample)
    {
        sample_body *pNext;

        if (pSample->m_Type == CFXTYPE_ELEMENT)
        {
            spuused+=pSample->m_Length;
        }
        else if (pSample->m_Type == CFXTYPE_ELEMENT_HYBRID)
        {
            iopused+=(pSample->m_Length+4095) &~4095;
        }
        else
        {
            streamused += pSample->m_Length;
        }

/*		if (GetTargetPlatform() == TARGET_TYPE_PC)
		{
			u32 size = sizeof(pSample->m_Filename);
            
//			u32 index = id|(Output.m_PackageId<<24);
//			x_fwrite(&size, sizeof(u32),1, fp_output);
//			x_fseek(fp_output, pSample->m_MediaLocation, X_SEEK_SET);
			x_fwrite(pSample->m_Filename, size, 1, fp_output);
//			x_fwrite(&index, sizeof(u32),1,fp_output);
//			id++;
		}
		else
		{
*/
			ASSERT((x_ftell(fp_output)-Base) == pSample->m_MediaLocation);
			x_fwrite(pSample->m_pData,pSample->m_Length,1,fp_output);

			zerolength = ((x_ftell(fp_output)+4095) & ~4095)-x_ftell(fp_output);
			if (zerolength)
			{
				x_fwrite(ZeroBuffer,zerolength,1,fp_output);
			}
			ASSERT((x_ftell(fp_output) & 4095)==0);
//		}
        pNext = pSample->m_pNext;
        x_free(pSample->m_pData);
        delete pSample;
        pSample = pNext;
    }
    Header.m_OffsetToSamples = TargetEndian32(Base);
    //
    // Write the proper header and index block to the start of our
    // output file.
    //
    x_fseek(fp_output,0,X_SEEK_SET);
    x_fwrite(&Header,1,sizeof(container_header),fp_output);
    AddLabelFooter(fp_label,Header.m_ContainerID);
    x_fclose(fp_output);
    x_fclose(fp_label);
    x_printf("Total SPU used %d bytes, IOP used %d bytes, %d bytes streamed\n",spuused,iopused,streamused);
}


s16 package_Adsr1(parse_envelope &Envelope)
{
    union
    {
        struct
        {
            unsigned int     SustainLevel:4;
            unsigned int     DecayRate:4;
            unsigned int     AttackRate:7;
            unsigned int     AttackMode:1;
        } split;
        s16 joined;
    } adsr1;

    adsr1.split.AttackMode = 0;         // Linear increment attack mode
    adsr1.split.AttackRate = 0;         // Attack rate 0.05ms
    adsr1.split.DecayRate = 0;          // Decay rate of 0.07ms
    adsr1.split.SustainLevel = 15;      // Sustain level of 1 (16/16)
    return adsr1.joined;
}

s16 package_Adsr2(parse_envelope &Envelope)
{
    union
    {
        struct
        {
            unsigned int    ReleaseRate:5;
            unsigned int    ReleaseMode:1;
            unsigned int    SustainRate:7;
            unsigned int    SustainMode:3;
        } split;
        s16 joined;
    } adsr2;

    adsr2.split.SustainMode = 0;          // Linear increment mode
    adsr2.split.SustainRate = 127;        // Sustain rate infinite
    adsr2.split.ReleaseMode = 0;          // Release mode linear decrement
    adsr2.split.ReleaseRate = 10;          // Release rate 46ms

    return adsr2.joined;
}
